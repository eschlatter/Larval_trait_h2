---
title: "Analyze model outputs"
author: "E Schlatter"
date: "1/14/2022"
output: html_document
---

```{r message=FALSE, warning=FALSE}
library(tidyverse)
library(MasterBayes) #for pedigree functions
library(MCMCglmm) #for running the model
library(MCMCpack) #for inverse wishart distributions
library(bayesplot) #mcmc_areas plot function
```

```{r}
source("../functions/model_fns.R")
load("../model_runs/SL_noparent_fulldata_10e5.RData")
load("../model_runs/SL_noparent_trimdata_10e5.RData")
```

## SL, no parental effects

### Full data: SL, no parental effects

```{r}
model_diagnostics(SL_noparent_fulldata_10e5[[1]])
```

```{r}
model_diagnostics(SL_noparent_fulldata_10e5[[2]])
```

```{r}
model_diagnostics(SL_noparent_fulldata_10e5[[3]])
```

```{r}
model_diagnostics(SL_noparent_fulldata_10e5[[4]])
#this one (invgamma2 prior) does the best, but still not great
```

```{r}
model_diagnostics(SL_noparent_fulldata_10e5[[5]])
```

### Trimmed data: SL, no parental effects

```{r}
#gets stuck at 0
model_diagnostics(SL_noparent_trimdata_10e5[[1]])
```

```{r}
#gets stuck at 0
model_diagnostics(SL_noparent_trimdata_10e5[[2]])
```

```{r}
model_diagnostics(SL_noparent_trimdata_10e5[[3]])
```

```{r}
#this one (invgamma2) still does the best. A little better than before --> reason to use the trimmed data
model_diagnostics(SL_noparent_trimdata_10e5[[4]])
```

```{r}
model_diagnostics(SL_noparent_trimdata_10e5[[5]])
```

### Further convergence diagnostics for selected model

So, the invgamma2 prior with trimmed data is best for SL, no parental effects. Let's generate 3 chains.

```{r}
#load 3 model runs (chains) generated in Run_Models.Rmd
load("../model_runs/SL_noparent_chains_fulldata.RData")
SL_noparent_chains <- SL_noparent_chains_fulldata

chain1 <- as.data.frame(SL_noparent_chains[[1]]$VCV)
chain1$chain <- 1
chain2 <- as.data.frame(SL_noparent_chains[[2]]$VCV)
chain2$chain <- 2
chain3 <- as.data.frame(SL_noparent_chains[[3]]$VCV)
chain3$chain <- 3

SL_noparent_chains_df <- rbind(chain1,chain2,chain3)
mcmc_trace(SL_noparent_chains_df)

## Gelman-Rubin diagnostic: looks good; upper limit is basically 1

intercept_gel=mcmc.list(SL_noparent_chains[[1]]$Sol,SL_noparent_chains[[2]]$Sol,SL_noparent_chains[[3]]$Sol)
clutch_gel=mcmc.list(SL_noparent_chains[[1]]$VCV[,'clutch'],SL_noparent_chains[[2]]$VCV[,'clutch'],SL_noparent_chains[[3]]$VCV[,'clutch'])
animal_gel=mcmc.list(SL_noparent_chains[[1]]$VCV[,'animal'],SL_noparent_chains[[2]]$VCV[,'animal'],SL_noparent_chains[[3]]$VCV[,'animal'])
units_gel=mcmc.list(SL_noparent_chains[[1]]$VCV[,'units'],SL_noparent_chains[[2]]$VCV[,'units'],SL_noparent_chains[[3]]$VCV[,'units'])

  #convergence diagnostic values (potential scale reduction factor):
  #"Approximate convergence is diagnosed when the upper limit is close to 1"
  #https://rdrr.io/cran/coda/man/gelman.diag.html
  gelman.diag(intercept_gel)
  gelman.diag(clutch_gel)
  gelman.diag(animal_gel)
  gelman.diag(units_gel)

  #accompanying plots
  par(mfrow=c(2,2))
  gelman.plot(intercept_gel)
  gelman.plot(clutch_gel,main="clutch")
  gelman.plot(animal_gel,main="animal")
  gelman.plot(units_gel,main="units")

```

### Results for selected model

```{r}
#all 3 chains
scaled_vars <- mcmc.list()
for(i in 1:3){
  varname <- paste('scale',colnames(SL_noparent_chains_df)[i],sep='_')
  scaled_vars[[varname]] <- SL_noparent_chains_df[,i]/rowSums(SL_noparent_chains_df[,1:3]) #store them in a list
}

mcmc_areas(scaled_vars,prob=0.95,area_method='scaled height')

#one chain -- similar
scaled_vars <- mcmc.list()
for(i in 1:3){
  varname <- paste('scale',colnames(chain2[i]),sep='_')
  scaled_vars[[varname]] <- chain2[,i]/rowSums(chain2[,1:3]) #store them in a list
}

mcmc_areas(scaled_vars,prob=0.95,area_method='scaled height')

model_results_df(SL_noparent_chains_df)
```


